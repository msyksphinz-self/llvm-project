//===- MYRISCVXInstrInfo.td - Target Description for MYRISCVX Target -*- tablegen -*-=//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file contains the MYRISCVX implementation of the TargetInstrInfo class.
//
//===----------------------------------------------------------------------===//

//@{ MYRISCVXInstrInfo_MYRISCVXRet
// MYRISCVXRetノードを定義する
def MYRISCVXRet : SDNode<"MYRISCVXISD::Ret", SDTNone,
                         [SDNPHasChain, SDNPOptInGlue, SDNPVariadic]>;
//@} MYRISCVXInstrInfo_MYRISCVXRet

//===----------------------------------------------------------------------===//
// MYRISCVX profiles and nodes
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// Instruction format superclass
//===----------------------------------------------------------------------===//
//@{ MYRISCVXInstrInfo_Include_td
include "MYRISCVXInstrFormats.td"   // 命令フォーマットを定義したMYRISCVXInstrFormats.tdをincludeする
//@} MYRISCVXInstrInfo_Include_td

//@{ MYRISCVXInstrInfo_Operand_Definition
//===----------------------------------------------------------------------===//
// MYRISCVX のオペランド定義
//===----------------------------------------------------------------------===//
// @{ MYRISCVXInstrInfo_Operand_Definition_simm12
// 12ビットの即値オペランド
def simm12 : Operand<XLenVT>, ImmLeaf<XLenVT, [{return isInt<12>(Imm);}]>;
// @} MYRISCVXInstrInfo_Operand_Definition_simm12
// @{ MYRISCVXInstrInfo_Operand_Definition_simm20u
// 上位20ビットで下位12ビットが0の即値オペランド
def simm20u : Operand<XLenVT>, ImmLeaf<XLenVT, [{return isInt<32>(Imm) && !(Imm & 0x0fff);}]>;
// @} MYRISCVXInstrInfo_Operand_Definition_simm20u
// @{ MYRISCVXInstrInfo_Operand_Definition_simm32
// 32ビットの即値オペランド
def simm32: Operand<XLenVT>, ImmLeaf<XLenVT, [{return isInt<32>(Imm);}]>;
// @} MYRISCVXInstrInfo_Operand_Definition_simm32
//@} MYRISCVXInstrInfo_Operand_Definition


// @{MYRISCVXInstrInfo_LO12_HI20
// 変換関数を定義する：定数のうち下位の12ビットを抽出する関数
def LO12sext : SDNodeXForm<imm, [{
  return CurDAG->getTargetConstant(SignExtend64<12>(N->getZExtValue()),
                                   SDLoc(N), N->getValueType(0));
}]>;

// 変換関数を定義する：定数のうち上位の20ビットを抽出する関数
def HI20 : SDNodeXForm<imm, [{
  return getImm(N, ((N->getZExtValue()+0x800) >> 12) & 0xfffff);
}]>;
// @}MYRISCVXInstrInfo_LO12_HI20


// shamt field must fit in 5 bits.
def immZExt_Xlen : Operand<XLenVT>, ImmLeaf<XLenVT, [{
  return Subtarget->is64Bit() ? isUInt<6>(Imm) : isUInt<5>(Imm);
}]>;

//@{ MYRISCVXInstrInfo_calltarget
def calltarget : Operand<iPTR> {
  let EncoderMethod = "getJumpTargetOpValue";
}
//@} MYRISCVXInstrInfo_calltarget

// JAL
def brtarget20    : Operand<OtherVT> {
  let EncoderMethod = "getBranch20TargetOpValue";
  let OperandType   = "OPERAND_PCREL";
}


// BEQ, BNE
def brtarget12    : Operand<OtherVT> {
  let EncoderMethod = "getBranch12TargetOpValue";
  let OperandType   = "OPERAND_PCREL";
}


// MYRISCVX Address Mode! SDNode frameindex could possibily be a match
// since load and store instructions from stack used it.
def addr_fi : ComplexPattern<iPTR, 1, "SelectAddrFI", [frameindex], []>;


//@{ MYRISCVXInstrInfo_Instruction_Format
//===----------------------------------------------------------------------===//
// Instructions specific format
//===----------------------------------------------------------------------===//
//@{ MYRISCVXInstrInfo_ArithLogicR
// 2レジスタオペランドを持つ算術論理演算命令
class ArithLogicR<bits<7> opcode, bits<3> funct3, bits<7>funct7,
                  string instr_asm, SDNode OpNode,
                  RegisterClass RC> :
  MYRISCVX_R<opcode, funct3, funct7, (outs RC:$rd), (ins RC:$rs1, RC:$rs2),
  !strconcat(instr_asm, "\t$rd, $rs1, $rs2"),
  [(set RC:$rd, (OpNode RC:$rs1, RC:$rs2))], IIAlu> {
    let isReMaterializable = 1;
}
//@} MYRISCVXInstrInfo_ArithLogicR


//@{ MYRISCVXInstrInfo_ArithLogicI
// 1レジスタオペランドと即値オペランドを持つ算術論理演算命令
class ArithLogicI<bits<7> opcode, bits<3> funct3,
                  string instr_asm, SDNode OpNode,
                  Operand Od, RegisterClass RC> :
  MYRISCVX_I<opcode, funct3, (outs RC:$rd), (ins RC:$rs1, Od:$simm12),
  !strconcat(instr_asm, "\t$rd, $rs1, $simm12"),
  [(set RC:$rd, (OpNode RC:$rs1, Od:$simm12))], IIAlu> {
    let isReMaterializable = 1;
}
//@} MYRISCVXInstrInfo_ArithLogicI

// JALRはI-typeの命令だがOpNodeを使用しない
//@{ MYRISCVXInstrInfo_ArithLogicI_J
class ArithLogicI_J<bits<7> opcode, bits<3> funct3,
                  string instr_asm,
                  Operand Od, RegisterClass RC> :
  MYRISCVX_I<opcode, funct3, (outs RC:$rd), (ins RC:$rs1, Od:$simm12),
  !strconcat(instr_asm, "\t$rd, $rs1, $simm12"), [], IIAlu> {
}
//@} MYRISCVXInstrInfo_ArithLogicI_J


//@{ MYRISCVXInstrInfo_ArithLogicU
// 1つの即値オペランドを持つ算術論理演算命令
class ArithLogicU<bits<7> opcode,
                  string instr_asm, RegisterClass RC, Operand Od> :
  MYRISCVX_U<opcode, (outs RC:$rd), (ins Od:$imm20),
    !strconcat(instr_asm, "\t$rd, $imm20"), [], IIAlu> {
      let isReMaterializable = 1;
}
//@} MYRISCVXInstrInfo_ArithLogicU
//@} MYRISCVXInstrInfo_Instruction_Format


//@{ MYRISCVXInstrInfo_jalr_variation
// JALR命令とそのエイリアスを定義する
def JALR : ArithLogicI_J<0b1100111, 0b000, "jalr", simm12, GPR>;
// エイリアスはjr / jalr / retの3つを定義する
def: InstAlias<"jr\t$rs",      (JALR ZERO, GPR:$rs, 0)>;
def: InstAlias<"jalr\t$rs",    (JALR RA,   GPR:$rs, 0)>;
def: InstAlias<"ret",          (JALR ZERO,      RA, 0), 2>;
//@} MYRISCVXInstrInfo_jalr_variation


//@{ MYRISCVXInstrInfo_LoadMemory_StoreMemory
// メモリロードストアのためのテンプレートを作成
let canFoldAsLoad = 1 in
class LoadMemory<bits<7> opcode, bits<3> funct3, string instr_asm, RegisterClass RC>:
  MYRISCVX_I<opcode, funct3, (outs RC:$rd), (ins GPR:$rs1, simm12:$simm12),
     !strconcat(instr_asm, "\t$rd, ${simm12}(${rs1})"),
     [], IILoad>;

class StoreMemory<bits<7> opcode, bits<3> funct3, string instr_asm, RegisterClass RC>:
  MYRISCVX_S<opcode, funct3, (outs), (ins RC:$rs2, GPR:$rs1, simm12:$simm12),
     !strconcat(instr_asm, "\t$rs2, ${simm12}(${rs1})"),
     [], IIStore>;
//@} MYRISCVXInstrInfo_LoadMemory_StoreMemory

//===----------------------------------------------------------------------===//
// Pattern fragment for load/store
//===----------------------------------------------------------------------===//

//@{ MYRISCVXInstrInfo_AlignedLoad_AlignedStore
class AlignedLoad<PatFrag Node> :
  PatFrag<(ops node:$ptr), (Node node:$ptr), [{
  LoadSDNode *LD = cast<LoadSDNode>(N);
  return LD->getMemoryVT().getSizeInBits()/8 <= LD->getAlignment();
}]>;

class AlignedStore<PatFrag Node> :
  PatFrag<(ops node:$val, node:$ptr), (Node node:$val, node:$ptr), [{
  StoreSDNode *SD = cast<StoreSDNode>(N);
  return SD->getMemoryVT().getSizeInBits()/8 <= SD->getAlignment();
}]>;
//@} MYRISCVXInstrInfo_AlignedLoad_AlignedStore

//===----------------------------------------------------------------------===//
// Instruction definition
//===----------------------------------------------------------------------===//
//@{ MYRISCVXInstrInfo_Basic_Definition
//===----------------------------------------------------------------------===//
// MYRISCVX Instructions
//===----------------------------------------------------------------------===//
//@{ MYRISCVXInstrInfo_Arithmetic
//@{ MYRISCVXInstrInfo_Arithmetic_ADDI
def ADDI : ArithLogicI<0b0010011, 0b000, "addi", add, simm12, GPR>;
//@} MYRISCVXInstrInfo_Arithmetic_ADDI
def XORI : ArithLogicI<0b0010011, 0b100, "xori", xor, simm12, GPR>;
def ORI  : ArithLogicI<0b0010011, 0b110, "ori",  or,  simm12, GPR>;
def ANDI : ArithLogicI<0b0010011, 0b111, "andi", and, simm12, GPR>;

def LUI  : ArithLogicU<0b0110111, "lui", GPR, simm20u>;
def ADD  : ArithLogicR<0b0110011, 0b000, 0b0000000, "add", add, GPR>;
def SUB  : ArithLogicR<0b0110011, 0b000, 0b0100000, "sub", sub, GPR>;
//@} MYRISCVXInstrInfo_Basic_Definition

//@{ MYRISCVXInstrInfo_RetRA
// RetRAノードの定義 RetRAは具体的な命令を持たない疑似ノード
// MYRISCVXRetはRetRAに変換される
let isReturn=1, isTerminator=1, hasDelaySlot=0, isBarrier=1, hasCtrlDep=1 in
  def RetRA : MYRISCVXPseudo<(outs), (ins), "", [(MYRISCVXRet)]>;
//@} MYRISCVXInstrInfo_RetRA

//===----------------------------------------------------------------------===//
//  Arbitrary patterns that map to one or more instructions
//===----------------------------------------------------------------------===//

// @{ MYRISCVXInstrInfo_LoadStore_PatFrags
// AlignedLoad / AlignStoreを継承してロードストアのためのOpNodeを生成する
def load_a          : AlignedLoad<load>;
def sextloadi8_a    : AlignedLoad<sextloadi8>;
def zextloadi8_a    : AlignedLoad<zextloadi8>;
def sextloadi16_a   : AlignedLoad<sextloadi16>;
def zextloadi16_a   : AlignedLoad<zextloadi16>;
def extloadi16_a    : AlignedLoad<extloadi16>;
def sextloadi32_a   : AlignedLoad<sextloadi32>;
def zextloadi32_a   : AlignedLoad<zextloadi32>;
def extloadi32_a    : AlignedLoad<extloadi32>;

def store_a         : AlignedStore<store>;
def truncstorei8_a  : AlignedStore<truncstorei8>;
def truncstorei16_a : AlignedStore<truncstorei16>;
def truncstorei32_a : AlignedStore<truncstorei32>;
// @} MYRISCVXInstrInfo_LoadStore_PatFrags


// @{ MYRISCVXInstrInfo_td_MemoryInsts
/// メモリアクセス命令の定義
def LW  : LoadMemory <0b0000011, 0b010, "lw",  GPR>;
def SW  : StoreMemory<0b0100011, 0b010, "sw",  GPR>;
def LB  : LoadMemory <0b0000011, 0b000, "lb",  GPR>;
def LBU : LoadMemory <0b0000011, 0b100, "lbu", GPR>;
def SB  : StoreMemory<0b0100011, 0b000, "sb",  GPR>;
def LH  : LoadMemory <0b0000011, 0b001, "lh",  GPR>;
def LHU : LoadMemory <0b0000011, 0b101, "lhu", GPR>;
def SH  : StoreMemory<0b0100011, 0b001, "sh",  GPR>;
// @} MYRISCVXInstrInfo_td_MemoryInsts


// Small immediates

// @{MYRISCVXInstrInfo_Pat_simm12
// 12ビットの定数を生成するパタン
def : Pat<(simm12:$in), (ADDI ZERO, simm12:$in)>;
// @}MYRISCVXInstrInfo_Pat_simm12

// @{MYRISCVXInstrInfo_Pat_simm20u
// 下位12ビットが0の定数を生成するパタン
def : Pat<(simm20u:$in), (LUI (HI20 imm:$in))>;
// @}MYRISCVXInstrInfo_Pat_simm20u
// @{MYRISCVXInstrInfo_Pat_simm32
// 一般的な32ビットの定数を生成するパタン
def : Pat<(simm32:$imm),
          (ADDI (LUI (HI20 imm:$imm)), (LO12sext imm:$imm))>;
// @}MYRISCVXInstrInfo_Pat_simm32


// Addr for Frame
def : Pat<(add (XLenVT addr_fi:$rs1), simm12:$simm12),
          (ADDI (XLenVT addr_fi:$rs1), simm12:$simm12)>;

// @{MYRISCVXInstrInfo_td_MemoryPattern_Define
// メモリアクセスのためのパタン定義
// multiclassは複数のパタン定義をまとめ上げることができる
multiclass LoadPattern<PatFrag LoadOp, MYRISCVXInst Inst> {
  def : Pat<(LoadOp GPR:$rs1)                          , (Inst GPR:$rs1, 0)                  >;
  def : Pat<(LoadOp addr_fi:$rs1)                      , (Inst addr_fi:$rs1, 0)              >;
  def : Pat<(LoadOp (add GPR:$rs1, simm12:$simm12))    , (Inst GPR:$rs1, simm12:$simm12)     >;
  def : Pat<(LoadOp (add addr_fi:$rs1, simm12:$simm12)), (Inst addr_fi:$rs1, simm12:$simm12) >;
}

multiclass StorePattern<PatFrag StoreOp, MYRISCVXInst Inst, RegisterClass RC> {
  def : Pat<(StoreOp RC:$rs2, GPR:$rs1)                          , (Inst RC:$rs2, GPR:$rs1, 0)                 >;
  def : Pat<(StoreOp RC:$rs2, addr_fi:$rs1)                      , (Inst RC:$rs2, addr_fi:$rs1, 0)             >;
  def : Pat<(StoreOp RC:$rs2, (add GPR:$rs1, simm12:$simm12))    , (Inst RC:$rs2, GPR:$rs1, simm12:$simm12)    >;
  def : Pat<(StoreOp RC:$rs2, (add addr_fi:$rs1, simm12:$simm12)), (Inst RC:$rs2, addr_fi:$rs1, simm12:$simm12)>;
}
// @}MYRISCVXInstrInfo_td_MemoryPattern_Define

// @{ MYRISCVXInstrInfo_td_MemoryPattern_Impl
// メモリアクセスのためのノードとMYRISCVXの命令を関連付ける
defm : LoadPattern<sextloadi8  , LB>;
defm : LoadPattern<extloadi8   , LB>;
defm : LoadPattern<sextloadi16 , LH>;
defm : LoadPattern<extloadi16  , LH>;
defm : LoadPattern<load        , LW>, Requires<[IsRV32]>;
defm : LoadPattern<zextloadi8  , LBU>;
defm : LoadPattern<zextloadi16 , LHU>;

defm : StorePattern<truncstorei8  , SB, GPR>;
defm : StorePattern<truncstorei16 , SH, GPR>;
defm : StorePattern<store         , SW, GPR>, Requires<[IsRV32]>;
// @} MYRISCVXInstrInfo_td_MemoryPattern_Impl


// @{ MYRISCVXInstrInfo_td_MemoryPattern64
// RV64のときは以下の命令を追加で定義する
let Predicates = [IsRV64] in {
  def LD  : LoadMemory <0b0000011, 0b011, "ld",  GPR>;
  def SD  : StoreMemory<0b0100011, 0b011, "sd",  GPR>;
  def LWU : LoadMemory <0b0000011, 0b110, "lwu", GPR>;

  /// Loads
  defm : LoadPattern<sextloadi32 , LW>;
  defm : LoadPattern<extloadi32  , LW>;
  defm : LoadPattern<zextloadi32 , LWU>;
  defm : LoadPattern<load        , LD>;

  /// Stores
  defm : StorePattern<truncstorei32 , SW, GPR>;
  defm : StorePattern<store         , SD, GPR>;
} // Predicates = [IsRV64]
// @} MYRISCVXInstrInfo_td_MemoryPattern64
